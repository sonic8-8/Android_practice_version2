package com.codingsonic.androidpractice

import android.os.Bundle
import androidx.activity.enableEdgeToEdge
import androidx.appcompat.app.AppCompatActivity
import androidx.core.view.ViewCompat
import androidx.core.view.WindowInsetsCompat
import com.codingsonic.androidpractice.databinding.ActivityMainBinding

class MainActivity : AppCompatActivity() {

    private lateinit var binding: ActivityMainBinding;

    override fun onCreate(savedInstanceState: Bundle?) {
        super.onCreate(savedInstanceState)

        binding = ActivityMainBinding.inflate(layoutInflater);
        setContentView(binding.root);

        // ---------------------------------------------------------------

        // 섹션 1. 안드로이드 스튜디오 설치 및 설정

        // 1. 프로젝트 생성 시 액티비티
        // 뷰 방식과 컴포즈 방식의 차이
        // Empty View Activity와 Empty Activity

        // 2. 프로젝트 생성 시 패키지명

        // 3. Logcat (로그캣)
        // 런타임 시에 로그를 확인할 수 있음

        // 4. SDK
        // settings - Language & Framework 확인
        // 안드로이드 에뮬레이터를 실행시키려면 SDK Tools 확인요
        // 인텔이면 에뮬레이터 엑셀레이터, AMD면 하이퍼바이저 드라이버 설치돼있으면 됩니다

        // 5. 다크모드, 폰트크기, 자동 import 등 원하는대로 설정하십쇼

        // ---------------------------------------------------------------

        // 섹션 2. AVD 구성 및 실행, 폰 테스트

        // 가상머신(애뮬레이터)에서 테스트하기
        // 1. Android Virtual Device아니면 흔히 Emulator라고 부름

        // 2. 네비게이션 모드 : 제스쳐 네비게이션, 3-button 네비게이션
        // 편한걸로 설정하십쇼

        // 3. Run 버튼 누르면 일어나는 일?
        // 빌드 진행 후 디바이스에 설치함

        // 실제 스마트폰에서 테스트하기
        // 1. 설정에서 USB 디버깅 허용해주면 됩니다
        // 삼성 안드로이드 USB 드라이버 다운받기
        // 설정 - 휴대전화 정보 - 소프트웨어 정보 - 빌드번호 7번 터치해서 개발자모드 활성화하면
        // 이제부터 개발자 옵션이 보이기 시작하구요
        // 중간에 내려보면 USB 디버깅 허용해주시면 됨

        // ---------------------------------------------------------------

        // 섹션 3. 앱 출시하기 관련 용어 정리 등

        // 1. 배포 파일을 추출해야 합니다.
        // APK 아니면 AAB 파일
        // APK와 AAB 차이는 뭘까요?
        // APK : Android Application Package는 옛날 방식이구요 요즘 사람들은
        // ABB : Android App Bundle은 2018년 구글에서 발표한 새로운 방식을 사용합니다
        // 이 방식이 주는 이점은 개발자가 파일을 100개 준비하더라도 사용자가 100개를 다운받도록 하지 않구요
        // 유저가 필요한 파일만 추출해서 다운로드 받게 한다는 것임
        //
        // 2. 앱을 배포하기 위해선 키로 서명되어있어야 함
        // 서명 방법
        // 이것도 예전이랑 바뀌었음
        // 옛날 방식은 배포할때 쓰는 키도 개발자가 만들고
        // 유저가 다운로드 받을때 쓰는 키도 개발자가 만듦
        // 그런데 키가 분실되거나 유출돼버리면 어떡할까요?
        // 업데이트가 불가능해짐. 새로 키를 만들어서 배포하면 이건 예전 앱과 다른 새로운 앱이 됨요.
        // 그래서 서명 방식이 바뀌었는데
        // 개발자가 쓰는 업로드 키, 구글에서 유저가 다운로드 할때 알아서 발급해주는 키를 따로 분리해서
        // 구글이 알아서 유저가 사용할 키를 발급해주는 방식이 됨요
        // 이 방식으로 바꿔서 관리가 편해졌음
        // 개념상으로만 알아두시면 됩니다.

        // 3. 앱 출시 준비물 ( 구글 플레이 스토어에서 정해놓은 방식임 )
        // AAB 파일
        // 앱 아이콘 이미지 : 스마트폰에서 보이는 이미지 아니구요. 플레이 스토어에서 보이는 앱 아이콘 이미지임
        // 그래픽 이미지 : 프로모션할때 보여지는 이미지구요. 어그로를 끌어야하니까 화려하게 ㄱㄱ
        // 스마트폰 스크린샷
        // 7인치, 10인치 태블릿 스크린샷 : 호환되는 기기 스크린샷 당연히 올리셔야합니다.

        // 4. AAB 배포 파일 만들기
        //
        // 1) 패키지명 변경
        // 패키지명이 고유해야 플레이스토어에 올릴 수 있다고 했습니다.
        // build.gradle.kts 파일에서 android - defaultConfig에서 패키지명 바꾸시면 됨요
        // com.example.xx 이런식이면 플레이스토어에서 거부하구요
        // 2) AAB 배포 파일 만들기
        // 3) 키 저장소와 업로드 키 만들기
        // 4) 앱 서명하기
        // 5) 릴리스용으로 빌드하기
        // 6) 빌드된 파일 확인 ( release 폴더에 있음 )

        // 5. 앱 출시하기
        // 앱을 올리려면 먼저 구글 플레이스토어에 개발자 계정을 생성해야합니다
        // 25달러를 내야 개발자 계정을 등록할 수 있구요
        // 비싸니까 25 달러 이상은 벌 수 있게 제대로 만들어 봅시다
        // 가이드 라인에 따라서 하라는 거 다하고 업로드 하시면 됩니다

        // ---------------------------------------------------------------

        // 섹션 4. 안드로이드 특징, 버전

        // 안드로이드는 리눅스 기반입니다.
        // 안드로이드 운영체제 주요 부분이나 구글이 만든 앱은 대부분 오픈소스니까 확인해보실 분들 확인 ㄱㄱ

        // 시스템 아키텍처를 정리해보고 이를 기반으로 어떻게 기능을 구현해나갈지 그려보도록 합시다.

        // 리눅스 커널 ->
        // 하드웨어 추상화 레이어 (HAL) ->
        // 네이티브 C/C++ 라이브러리 / 안드로이드 런타임 ( ART VM이 실행시켜줌 ) ->
        // 자바 API 프레임워크 ->
        // 시스템 앱

        // 자바와 다른 점?
        // 자바에서는 자바 소스 코드를 자바 바이트 코드로 바꾸고 JVM에서 실행시키면 끝이었습니다.
        // 근데 코틀린에서는 조금 다름
        // 자바 소스 코드를 자바 바이트 코드(.class)로 만들고
        // 한 번 더 컴파일 해줍니다.
        // 자바 바이트 코드를 DEX 바이트 코드로 바꾸고 나서
        // ART Virtual Machine이 실행시켜줌
        // 왜 이렇게 하느냐? 구글에서는 퍼포먼스 증가를 위해서 DEX 파일 포맷을 만든 것이라고 함
        // 불만 사항이 있으면 저한테 하지마시고 구글에게 하시면 됩니다

        // 개발자들은 운영체제 버전보다 API 레벨이 중요합니다
        // API 레벨로 메서드 등이 지원되기 시작한 시기를 알 수 있음
        // onKeyShortcut 메서드는 API 레벨 11부터 추가됐다든지 하는식
        // 안드로이드 14, 코드명 UpsideDownCake


        // ---------------------------------------------------------------

        // 섹션 5. 개발 방식 : 컴포넌트 기반 개발, 리소스 활용 개발

        // 1. 안드로이드는 컴포넌트 기반 개발
        // 클래스는 일반 클래스와 컴포넌트 클래스로 나뉩니다

        // 개발자가 직접 코드로 필요할때 만들고 필요없을때 지우는 것은 일반 클래스고
        // 개발자가 만든 클래스이긴 한데 안드로이드 시스템에 의해서 생성과 소멸이 관리된다면 컴포넌트 클래스임

        // 컴포넌트는 4종류로 구분됨
        // 1) 액티비티 컴포넌트 : 화면 구성
        // 2) 서비스 컴포넌트 : 백그라운드에서 실행되는 업무 ( 카카오톡 등 )
        // 3) 콘텐츠 프로바이더 컴포넌트 ( 줄여서 콘텐츠 컴포넌트라고 함 ) : 앱과 앱간의 데이터 공유
        // 4) 브로드캐스트 리시버 컴포넌트 ( 줄여서 리시버 컴포넌트라고 함 ) : 이벤트(사용자가 클릭하거나 하는거 아님, 부팅 완료 시점 같은 것들이구요)가 발생할 때 실행되는 컴포넌트

        // 컴포넌트 클래스는 어떻게 만드느냐?
        // 상속받아서 만들면 됩니다.
        // Activity, Service, ContentProvider, BroadcastReceiver 같은 상위 클래스를 상속받으면 됨

        // 2. 컴포넌트는 앱 안에서 독립된 실행 단위다.
        // 컴포넌트끼리 종속되지 않아서 코드 결합이 발생하지 않음요
        // 시스템에게 요청을 보내서 실행해달라고 해야함
        // 실행 시점이 다양함
        // 이게 무슨말이냐? 유저가 앱 아이콘 클릭하는 순간이 실행 시점 아님? 이것도 맞구요
        // 근데 카카오톡 같은 앱은 우리가 아이콘 클릭하지도 않았는데 알림이 실행되는데요? 이것도 맞습니다
        // 그래서 실행 시점이 다양하다고 하는 것임
        // 다시 말하면 main() 함수같은 하나의 시작 지점이 없음요

        // 애플리케이션 라이브러리를 사용할 수 있음
        // 이게 뭐냐구요 쉽게 말해서 안드로이드 시스템이 컴포넌트를 실행해주기 때문에
        // 내가 만든 앱에서 다른 사람이 만든 앱을 실행시켜달라고 요청하면 안드로이드 시스템이 그걸 실행시켜주는 겁니다
        // 대표적인게 카카오톡에서 카메라 버튼을 누르면 카메라 앱이 실행되는거구요
        // 사용자는 카카오톡에서 카메라도 지원해주나보다 라고 생각할 수 있겠지만 사실 버튼 누르면 카메라 실행시켜달라고
        // 요청 보내서 안드로이드 시스템이 실행시켜준거임

        // 3. 리소스를 활용하는 개발
        // 안드로이드는 리소스를 굉장히 좋아함
        // 일반적으로 리소스라고 하면 문자열 같은 것들을 리소스로 사용하는 경우가 대부분인데
        // 안드로이드에서는 정적인 것들은 다 리소스로 만들고 사용함요
        // 리소스가 무엇이냐면 틀이나 형태, 그림, 바뀌지 않는 글자 등 정적인 것들이라고 생각하면 됩니다. 이런것들을 리소스 파일로 만들 수 있음
        // 리소스 외부화 ★
        // 안드로이드 외부화를 왜 xml로 하느냐?
        // 안드로이드에서는 리소스를 매우 좋아한다고 했습니다.
        // 자세히보니 화면 레이아웃도 고정된 것들이고 내용물만 바뀌는데 이것도 리소스로 분리하면 좋겠는데라고 생각한 것임
        // 그래서 이런 레이아웃 같은것들도 다 리소스 외부화하려고 적당한 xml 파일로 만든 것

        // ---------------------------------------------------------------

        // 섹션 6. 폴더, 파일 구조

        // 1. 탐색창에서 보이는 폴더 구조와 안드로이드 스튜디오에서 보여주는 폴더 구조가 다름
        // 프로젝트 -> 모듈 -> src -> main
        // 프로젝트 안에 모듈을 추가할 수 있음
        // 그리고 이 모듈이 애플리케이션 단위임
        // 모든 모듈이 애플리케이션 모듈인 건 아니고 라이브러리로만 사용하기 위한 모듈도 있음

        // AndroidManifiest.xml : 런타임 시 환경 설정 파일임
        // Gradle Scripts : 빌드 환경 설정 파일 모음
        // kotlin+java : 패키지명 아래에 메인 액티비티 파일 들어있음
        // res는 Resources의 줄임말입니다
        // 안드로이드는 리소스를 굉장히 좋아한다고 했었음
        // 정적이기만 하면 다 리소스로 만들어서 개발하려고 하기 때문에 개발을 진행하다보면 자연스럽게 res 폴더안에
        // 많은 리소스 폴더와 파일이 생성됨

        // 2. build.gradle.kts
        // 처음만들면 2개가 있는데 오른쪽 괄호를 보면 조금 다른 걸 알 수 있습니다
        // 프로젝트 수준의 설정 파일, 모듈 수준의 설정 파일이구요
        // 모듈을 1개 만들때마다 모듈 수준 설정 파일이 하나씩 추가됨
        // 프로젝트 수준 설정 파일은 거의 건들 일이 없음
        // 모듈 수준 설정 파일에 집중하시면 됨
        // 플랫폼 API, 오픈소스 그룹에서 만든 API, 서드파트 벤더가 제공하는 API를 모두 활용해서 개발을 진행하구요
        // 현재 안드로이드 개발자들의 사용비율이 굉장히 높은 라이브러리들은 안드로이드 스튜디오에서 자동으로 추가해주는데
        // 5개 정도 추가돼있음요
        // 근데 이걸 누가 만들었죠? 구글에서 만들었습니다.
        // 근데 왜 플랫폼 API로 등록이 안되어있음?
        // 구글이 서드파트 벤더로 제공한 API라서 그렇습니다
        // libs.versions.toml에서 라이브러리를 관리하는 방식으로 안드로이드 스튜디오에서 바뀜
        // 추가로 testImplementation은 테스트 관련 라이브러리입니다

        // 3. AndroidManifest.xml
        // application 태그에서 icon, label(앱 이름), theme 등을 바꿀 수 있음
        // 안드로이드 시스템이 내가 만든 클래스가 컴포넌트 클래스라고 인식하게 하기 위해서 해줘야할 게 있는데요
        // application 태그 안쪽에 컴포넌트 클래스를 등록해줘야 합니다
        // 컴포넌트는 종류에 따라 태그를 다르게 써줘야합니다.
        // activity 컴포넌트는 activity 태그로 서비스 컴포넌트는 service 태그로, 기타 receiver, provider도 마찬가지임
        // 그리고 컴포넌트로 등록한 다음 안쪽에 Intent-filter 태그가 보이는데요
        // ( 프로젝트 생성 시 기본적으로 만들어지는 걸 태그들을 보고 말하는 중임 )
        // Intent-filter 태그를 삭제해도 빌드가 잘되고 앱 설치도 됩니다
        // 근데 아이콘이 안보이는데요
        // Intent-filter 태그가 없어서 그렇구요
        // action 태그와 category 태그가 하는 역할은 앱 아이콘을 클릭했을때 실행되는 액티비티라는 의미임

        // 4. 리소스 폴더
        // 어떤 매커니즘으로 리소스가 활용이 되는지 알아보도록 합시다
        // 원래 리소스 파일로 분리되어있는 것들은 개발자가 작성한 코드에 들어가있던 내용임
        // 실행됐을때 이용할 수 있게 하려면 그렇게 해야함
        // 그런데 정적이라는 이유만으로 리소스 파일로 분리했습니다.
        // 이 리소스 파일은 실행했을때 코드에 안들어가있는데 어떻게 이용하게 할 것임?

        // 리소스 파일들을 연결시켜주면 되지 않을까요
        // 이걸 가능하게 하는게 R.java 파일이구요
        // 연결시키려면 리소스가 뭐가 뭔지 식별해야 이용할 수 있어서 R.java 파일에는 리소스 파일명으로 변수를 만들고 이것을 식별하는 정수를 할당해놓습니다.
        // 예를 들어, res/layout/test.xml 파일을 만들었다면 R.java 파일에 R.layout.test라는 변수를 생성하는 것임
        // 이 방식을 사용하려면 지켜야할 규칙이 있는데요
        // 1) res 하위의 폴더는 지정된 파일명을 써야함
        // 2) 폴더 안에 하위 폴더 생성 불가
        // 3) 자바 이름 규칙 위배 안됨
        // 4) 리소스 파일명에는 알파벳 대문자 이용 불가능
        // 만든 사람이 이렇게 써야 구동되게 해놨으니까 지키시면 됨

        // 5. 레이아웃 xml, MainActivity

        // 메인 액티비티 컴포넌트 클래스를 살펴보면
        // AppCompatActivity라는 서브 클래스를 상속받아서 액티비티 컴포넌트를 만들었습니다
        // 이건 나중에 보도록 하구요
        // 이번에 안드로이드 스튜디오가 업데이트 되면서 enableEdgeToEdge() 와 그 밑쪽 코드가 새로 생겼습니다
        // enableEdgeToEdge() 메서드를 사용하면 status bar(위쪽)와 navigation bar(아래쪽)의 공간도 모두 액티비티 컴포넌트가 차지하게 해줌
        // 아래쪽 setContentView() 밑쪽 코드는 액티비티 컴포넌트가 네비게이션바나 스테이터스바와 겹치지 않게 설정해주는겁니다
        // 필요없으면 지우시면 되구요


    }
}